[
  {
    "projectId": "a5b41820-de34-476a-9fd1-1dfd5aa01ae0",
    "testId": "2b291fa8-9f07-413b-9368-4fc0a96a708c",
    "userId": "e4283418-8081-70a7-95f1-f4fc6b97d680",
    "title": "TC001-Landing page loads and shows core hero/branding content",
    "description": "Verifies the landing page renders successfully and the primary brand messaging is visible on initial load.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Nébula').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Expected landing page brand text 'Nébula' to be visible on initial load, but it was not found. The page may not have rendered correctly or the primary brand messaging is missing.\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Verification summary:\n- Page load: Rendered successfully (visual hero and header content present).\n- Title: Contains 'NÉBULA' (tab title: 'NÉBULA STUDIO | Dark Premium A') - Verified.\n- Brand text: 'NÉBULA' and 'STUDIO' visible in header/branding - Verified.\n- Primary hero messaging: Large headline 'Seu talento é raro. Sua presença digital precisa ser' visible - Verified.\n- <main> element: No interactive index labeled <main> found in current page state (visibility unknown/not verified).\n- Dark Premium aesthetic: Confirmed visually (dark gradient background, large white display typography, premium CTAs).\n- 'Sua jornada estelar' section: Not found on initial load (text not present in current page state).\n- Floating WhatsApp: Chat prompt/CTA is present (elements indicating WhatsApp chat and 'Vamos conversar?' visible). Functionality not clicked/tested.\n- Links: Navigation and CTA links are present (page_stats reports 8 links). Links were not individually clicked for accessibility testing.\nRemaining/Recommended actions if full verification required:\n- Locate or confirm presence of a <main> element in the DOM (inspect DOM or developer tools) or provide the element index.\n- Click the WhatsApp floating button to verify it opens the expected chat or link.\n- Click through nav/CTA links to confirm they are accessible and not broken.\nOverall status: Primary brand messaging and dark premium aesthetic are visible on initial load. Some requested checks (presence of <main>, existence of 'Sua jornada estelar', and active testing of WhatsApp & links) remain unverified. Please confirm if additional interactions (clicks) should be performed. ",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/e4283418-8081-70a7-95f1-f4fc6b97d680/1771260803907802//tmp/test_task/result.webm",
    "created": "2026-02-16T16:52:33.571Z",
    "modified": "2026-02-16T16:53:24.020Z"
  },
  {
    "projectId": "a5b41820-de34-476a-9fd1-1dfd5aa01ae0",
    "testId": "ce067ca9-872c-42f0-82ee-468f75b5ba43",
    "userId": "e4283418-8081-70a7-95f1-f4fc6b97d680",
    "title": "TC002-Scroll to and view the \"Sua jornada estelar\" (Journey) section",
    "description": "Verifies the user can scroll the landing page and reach the Journey section content.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/e4283418-8081-70a7-95f1-f4fc6b97d680/1771260928205927//tmp/test_task/result.webm",
    "created": "2026-02-16T16:52:33.577Z",
    "modified": "2026-02-16T16:55:28.348Z"
  },
  {
    "projectId": "a5b41820-de34-476a-9fd1-1dfd5aa01ae0",
    "testId": "ce5af16f-3d62-4144-bfd6-03ad3b5b73d5",
    "userId": "e4283418-8081-70a7-95f1-f4fc6b97d680",
    "title": "TC003-Scroll to and view the Client Testimonials section",
    "description": "Verifies the testimonials area is reachable and visible when scrolling the landing page.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/e4283418-8081-70a7-95f1-f4fc6b97d680/1771260827556841//tmp/test_task/result.webm",
    "created": "2026-02-16T16:52:33.585Z",
    "modified": "2026-02-16T16:53:47.702Z"
  },
  {
    "projectId": "a5b41820-de34-476a-9fd1-1dfd5aa01ae0",
    "testId": "29845b1b-eb44-4b46-ac1d-8179d830b340",
    "userId": "e4283418-8081-70a7-95f1-f4fc6b97d680",
    "title": "TC004-End-to-end scroll journey: Journey section then Testimonials section",
    "description": "Verifies a complete visitor flow through key sections in sequence on the landing page.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Try to find the exact text 'Client Testimonials'; if absent, find and scroll to 'Depoimentos' and verify its visibility. Then click the floating WhatsApp button to test its behavior.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/section[1]/div[2]/div/div[3]/span[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Client Testimonials').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: expected the landing page to show 'Client Testimonials' (verifying the visitor can reach key sections and view testimonials); the section was not found or not visible, so the visitor flow verification failed\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Verification summary (visitor flow check stopped as requested):\n\nOverall status: PARTIAL - success=false. The landing page flow was exercised; one requested item ('Client Testimonials' in English) is absent so the flow is not fully satisfied.\n\n1) Main navigation links (visible text, href/target, clickable):\n- Services: href=\"#servicos\" — present and appears clickable.\n- Portfolio: href=\"#portfolio\" — present and appears clickable.\n- Process: href=\"#processo\" — present and appears clickable.\n- FAQ: href=\"#faq\" — present and appears clickable.\n\n2) Floating WhatsApp CTA and nearby text:\n- Plain nearby text: \"Resposta rápida no WhatsApp.\" — present as a span/label, not a link.\n- CTA link: visible text \"Vamos conversar?\" (index 208) — href=\"#\" (internal anchor), present and clickable. Clicking triggered an internal anchor/behavior; no external WhatsApp URL (wa.me/ or api.whatsapp.com) was opened or returned. Conclusion: CTA does not open an external WhatsApp chat in this environment — it points to an internal target/hash.\n\n3) Testimonials section (Portuguese 'Depoimentos'):\n- Present: Yes.\n- Heading: \"Depoimentos\"\n- Subheading (nearby): \"O que nossos clientes dizem\"\n- First 3 visible lines captured:\n  1. \"★★★★★\"\n  2. \"\\\"Em 3 dias eu tinha um site que\"\n  3. \"parecia de agência grande. Meus agendamentos triplicaram no primeiro mês!\\\"\"\n\n4) 'Sua jornada estelar' section (under header '04 — PROCESSO'):\n- Location: Under header '04 — PROCESSO' (previously located and re-confirmed).\n- Visible copy (summary, up to 3 lines + list):\n  - \"01 — Diagnóstico — Gratuito. Entendemos seu negócio.\"\n  - \"02 — Direção Criativa — Definimos o caminho visual.\"\n  - \"03 — Identidade Visual — Criamos sua marca completa.\"\n  - (additional lines visible: \"04 — Posts & Vídeos — Conteúdo que vende.\", \"05 — Entrega — Tudo organizado pra você.\", \"06 — Acompanhamento — Mensal (opcional).\")\n- Dark Premium aesthetic cues (visual observations from the page/screenshot):\n  - Background tone: deep, near-black canvas with subtle purple-to-blue gradient veining across the hero.\n  - Gradients: soft radial/linear gradient with purple (left) transitioning to teal/blue (right), producing a luminous nebula-like backdrop.\n  - Prominent colors: heavy use of pure white for main display headline, purple accent (cursor/line), muted cool-gray for supporting copy, and white/soft borders on CTA buttons.\n  - Font weight/scale: very large, heavy-weight display heading (high scale for hero), medium-weight small paragraph copy; buttons are bold and compact — overall premium, high-contrast typographic scale.\n  - Notes: page styling details are visible in screenshot (gradient, contrast, large display type); explicit CSS values were not present in extracted markdown but visual inspection confirms a Dark Premium aesthetic.\n\nNotes and blockers:\n- Requested English text 'Client Testimonials' is not present on the page. The Portuguese section 'Depoimentos' is the equivalent and was inspected instead.\n- The WhatsApp CTA did not open an external chat link in this environment; it resolves to an internal anchor/hash ('#'). If external WhatsApp behavior must be confirmed, a different environment or interaction may be required (or inspecting a live deployment that links to wa.me/api.whatsapp.com).\n\nIf further actions are desired (for example: open the internal anchor to inspect the modal content, inspect network requests after clicking the CTA, or test the nav links to navigate to the actual sections), provide confirmation and the next steps will be executed. Otherwise, this verification is complete and stopped as requested.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/e4283418-8081-70a7-95f1-f4fc6b97d680/1771260944471062//tmp/test_task/result.webm",
    "created": "2026-02-16T16:52:33.591Z",
    "modified": "2026-02-16T16:55:44.592Z"
  },
  {
    "projectId": "a5b41820-de34-476a-9fd1-1dfd5aa01ae0",
    "testId": "39a21168-e055-4a8f-a662-d9e273c8df53",
    "userId": "e4283418-8081-70a7-95f1-f4fc6b97d680",
    "title": "TC005-Visual aesthetic presence: glassmorphism and neon-like elements appear",
    "description": "Verifies the page presents visible dark-premium visual treatment using glass/overlay and neon-accent elements.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the floating WhatsApp anchor (index 210) to verify the link/button functionality and observe resulting behavior.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/section[1]/div[2]/div/div[3]/span[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "Medium",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/e4283418-8081-70a7-95f1-f4fc6b97d680/1771260864266498//tmp/test_task/result.webm",
    "created": "2026-02-16T16:52:33.598Z",
    "modified": "2026-02-16T16:54:24.452Z"
  },
  {
    "projectId": "a5b41820-de34-476a-9fd1-1dfd5aa01ae0",
    "testId": "470b2513-f2c7-45ed-a800-9c51b0ca9b34",
    "userId": "e4283418-8081-70a7-95f1-f4fc6b97d680",
    "title": "TC006-Animations present during scroll without requiring performance validation",
    "description": "Verifies animated interactions appear as the user scrolls through the landing page (without measuring FPS).",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Scroll down one full viewport to trigger animations in the visible cards/section, then click the floating WhatsApp element to verify it opens/is functional.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/section[1]/div[2]/div/div[3]/span[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Scroll one viewport to ensure visible elements are in view, expand an FAQ accordion to observe its expand transition, then click the floating WhatsApp button once to confirm it opens. Wait after each action to observe animations.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/section[8]/div/div[2]/details[1]/summary').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "Medium",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/e4283418-8081-70a7-95f1-f4fc6b97d680/1771261128197878//tmp/test_task/result.webm",
    "created": "2026-02-16T16:52:33.604Z",
    "modified": "2026-02-16T16:58:48.342Z"
  },
  {
    "projectId": "a5b41820-de34-476a-9fd1-1dfd5aa01ae0",
    "testId": "bd5b3d82-8232-4925-94ac-287846427417",
    "userId": "e4283418-8081-70a7-95f1-f4fc6b97d680",
    "title": "TC007-Successful contact form submission shows confirmation message without page reload",
    "description": "Verifies that submitting valid required fields replaces the contact form with a confirmation message on the same page.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'INICIAR RITUAL' link (index 101) to navigate to the contact (#contato) section.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/header/div/nav/a[5]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Type 'Teste Nome' into the 'Nome' field (input index 6), then fill the 'Contato' field (index 7) and submit (click index 1069).\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/section[9]/div/div[2]/div/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Teste Nome')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/section[9]/div/div[2]/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('teste@exemplo.com')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/section[9]/div/div[2]/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        ```\n        try:\n            await expect(frame.locator('text=obrigado').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: After submitting the contact form with valid required fields, the confirmation message 'obrigado' did not appear, so the form was not replaced by the expected confirmation on the same page.\")\n        ```\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Result summary:\n- Steps executed: navigated to /#contato, confirmed contact form visible, filled required fields (Nome and Contato), clicked submit.\n- Observed behavior: clicking submit opened a new browser tab (tab id B744) with the form values in the URL query string. The page in the active tab (B744) still shows the contact form inputs and the submit button (input indexes 1751, 1754 and button 1756). No confirmation message containing the text 'obrigado' was found on the page. The 'Nome' input is still visible, so the form was not replaced in-place by a confirmation message.\n- Conclusion: The requirement \"submitting valid required fields replaces the contact form with a confirmation message on the same page\" was not met. Submission opened a new tab and the form remains visible; confirmation not present.\n- Recommendation: If in-page confirmation is required, inspect the form submission handler to ensure it does not open a new tab (target/_blank) or redirect externally, and ensure client-side code replaces the form with the confirmation message on success. If further verification is desired, provide instructions to attempt submission again in the original tab or share server-side logs.\n",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/e4283418-8081-70a7-95f1-f4fc6b97d680/1771260860842903//tmp/test_task/result.webm",
    "created": "2026-02-16T16:52:33.610Z",
    "modified": "2026-02-16T16:54:21.050Z"
  },
  {
    "projectId": "a5b41820-de34-476a-9fd1-1dfd5aa01ae0",
    "testId": "5110829d-fe06-475b-9ea5-8a89b477a305",
    "userId": "e4283418-8081-70a7-95f1-f4fc6b97d680",
    "title": "TC008-Empty required fields show inline validation errors",
    "description": "Verifies that leaving Nome and Contato empty triggers visible inline validation errors and blocks submission.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the element that navigates to the contact section (index 208, 'Vamos conversar?').\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/section[1]/div[2]/div/div[3]/span[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the Submit button to submit the empty form and trigger inline validation (click element index 1069).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/section[9]/div/div[2]/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=obrigatório').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Expected inline validation error 'obrigatório' to be visible for the Nome and Contato fields after submitting an empty form, but it was not found — validation did not trigger or the form was submitted\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Verification summary:\n\n1) 'Nome' / 'Nome Completo': Present — exact snippet found: \"Nome Completo\".\n2) 'Contato' / 'WhatsApp (com DDD)': 'Contato' label not found. 'WhatsApp (com DDD)' is present — exact snippet: \"WhatsApp (com DDD)\".\n3) Inline Portuguese validation text ('obrigatório' / 'campo obrigatório'): Absent — no matching snippet found.\n4) Native browser validation tooltip: Present — visible tooltip text (English) shown in the screenshot: \"Please fill out this field.\" (this blocked the submission).\n5) Confirmation/thank-you text ('obrigado'): Absent — no matching snippet found.\n\nConclusion: The form submission is blocked when Nome and Contato are left empty (no thank-you page or confirmation observed). The blocking is caused by the browser's native validation tooltip (\"Please fill out this field.\"), not by an inline Portuguese validation message. Therefore the requirement to block submission is met, but the requirement to show visible inline Portuguese validation errors is not met.\n\nResult: Partial functional blocking observed, but expected inline Portuguese validation messages are missing.\n\n\nAttachments:\n\nextracted_content_0.md:\n<url>\nhttp://localhost:3000/#\n</url>\n<query>\nCheck page for these items and return concise results (present/absent) and any exact snippet found: 1) 'Nome' or 'Nome Completo' visible on page; 2) 'Contato' or 'WhatsApp (com DDD)' visible; 3) any inline validation text in Portuguese such as 'obrigatório' or 'campo obrigatório' visible; 4) any native browser validation tooltip text like 'Please fill out this field.' visible; 5) any confirmation/thank-you text like 'obrigado' visible. Provide exact matching snippets where found.\n</query>\n<result>\n1) 'Nome' / 'Nome Completo': Present\nExact snippet: \"Nome Completo\"\n\n2) 'Contato' / 'WhatsApp (com DDD)':\n- \"Contato\": Absent\n- \"WhatsApp (com DDD)\": Present\nExact snippet: \"WhatsApp (com DDD)\"\n(also present elsewhere as: \"chatResposta rápida no WhatsApp. Vamos\\nconversar?\")\n\n3) Inline validation text in Portuguese ('obrigatório' / 'campo obrigatório'): Absent — no matching snippet found.\n\n4) Native browser validation tooltip text ('Please fill out this field.'): Absent — no matching snippet found.\n\n5) Confirmation/thank-you text ('obrigado'): Absent — no matching snippet found.\n</result>",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/e4283418-8081-70a7-95f1-f4fc6b97d680/1771260918166513//tmp/test_task/result.webm",
    "created": "2026-02-16T16:52:33.617Z",
    "modified": "2026-02-16T16:55:18.290Z"
  },
  {
    "projectId": "a5b41820-de34-476a-9fd1-1dfd5aa01ae0",
    "testId": "b246288f-649d-4d0f-a46f-7d1e9307741a",
    "userId": "e4283418-8081-70a7-95f1-f4fc6b97d680",
    "title": "TC009-Only Nome filled still requires Contato and does not submit",
    "description": "Verifies the form blocks submission when Contato is empty and shows a required-field error for Contato.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open the contact section by clicking the link that navigates to the contato section (likely the 'Vamos conversar?' link).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/section[1]/div[2]/div/div[3]/span[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Type 'Teste Nome' into the Nome field (index 8) and then click the Submit button (index 1071) to trigger validation for the Contato field.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/section[9]/div/div[2]/div/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Teste Nome')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/section[9]/div/div[2]/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        frame = context.pages[-1]\n        await page.wait_for_timeout(1000)\n        await frame.locator('text=Contato').wait_for(state='visible', timeout=5000)\n        assert await frame.locator('text=Contato').is_visible(), 'Expected \"Contato\" to be visible'\n        await frame.locator('text=obrigatório').wait_for(state='visible', timeout=5000)\n        assert await frame.locator('text=obrigatório').is_visible(), 'Expected \"obrigatório\" error to be visible'\n        await page.wait_for_timeout(500)\n        assert not await frame.locator('text=obrigado').is_visible(), 'Expected \"obrigado\" to NOT be visible'\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "Medium",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/e4283418-8081-70a7-95f1-f4fc6b97d680/1771260898989568//tmp/test_task/result.webm",
    "created": "2026-02-16T16:52:33.622Z",
    "modified": "2026-02-16T16:54:59.103Z"
  },
  {
    "projectId": "a5b41820-de34-476a-9fd1-1dfd5aa01ae0",
    "testId": "f5ae3983-2c42-4afa-a40f-85dcac60ffc5",
    "userId": "e4283418-8081-70a7-95f1-f4fc6b97d680",
    "title": "TC010-Only Contato filled still requires Nome and does not submit",
    "description": "Verifies the form blocks submission when Nome is empty and shows a required-field error for Nome.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'INICIAR RITUAL' (likely contact anchor) element to navigate/scroll to the contact section (#contato).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/header/div/nav/a[5]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Type the phone into the Contato field (input index 11), click the submit button (index 1072), then extract page content to check visibility of 'Nome', 'obrigatório', and absence of 'obrigado'.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/section[9]/div/div[2]/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('(11) 99999-9999')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/section[9]/div/div[2]/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        # -> Assertions: verify validation for empty Nome and absence of success message\n        # Ensure the 'Nome' label/text is visible on the page\n        assert await frame.locator(\"text=Nome\").is_visible(), \"Expected text 'Nome' to be visible\"\n        \n        # After submitting with empty Nome, the required-field error 'obrigatório' should appear\n        await frame.locator(\"text=obrigatório\").wait_for(state=\"visible\", timeout=5000)\n        assert await frame.locator(\"text=obrigatório\").is_visible(), \"Expected 'obrigatório' validation message to be visible\"\n        \n        # Ensure success/thank-you message 'obrigado' is NOT visible (submission should be blocked)\n        # small pause to allow any success UI to appear if it would\n        await frame.wait_for_timeout(1000)\n        assert await frame.locator(\"text=obrigado\").count() == 0, \"Did not expect 'obrigado' to be visible (form should not submit)\"\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "Medium",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/e4283418-8081-70a7-95f1-f4fc6b97d680/1771260860335782//tmp/test_task/result.webm",
    "created": "2026-02-16T16:52:33.628Z",
    "modified": "2026-02-16T16:54:20.449Z"
  },
  {
    "projectId": "a5b41820-de34-476a-9fd1-1dfd5aa01ae0",
    "testId": "eeed0324-89be-4ca7-a095-8ca919e622da",
    "userId": "e4283418-8081-70a7-95f1-f4fc6b97d680",
    "title": "TC011-Confirmation message appears in the contact section after submission",
    "description": "Verifies the success message is shown within the contact area and the form is no longer presented after submit.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'INICIAR RITUAL' button (index 101) to navigate/scroll to the contact section (#contato).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/header/div/nav/a[5]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the contact form: enter Nome 'Cliente Potencial', enter Contato '@cliente', then click the submit button to trigger the success message.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/section[9]/div/div[2]/div/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Cliente Potencial')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/section[9]/div/div[2]/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('@cliente')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/section[9]/div/div[2]/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=obrigado').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: expected the contact form submission to display the success message 'obrigado' in the contact area and remove the form, but the confirmation did not appear (the form may still be present)\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Verificação final concluída (resultado: falha na expectativa).\n\nResumo objetivo dos achados:\n- Presença da mensagem de sucesso 'obrigado': Não encontrada no conteúdo da página (buscas realizadas; exatamente 'obrigado' não está presente).\n\n- Estado dos elementos do formulário após submissão:\n  - Campo Nome (index 1824): Visível. Trecho próximo: \"Inicie seu Projeto\\nNome Completo\".\n  - Campo WhatsApp (index 1827): Visível. Trecho próximo: \"Nome Completo\\nWhatsApp (com DDD)\".\n  - Botão de submit (index 1829) - \"Solicitar Orçamento VIP\": Visível. Trecho próximo: \"WhatsApp (com DDD)\\nSolicitar Orçamento VIP\".\n\n- Observação sobre submissão: O clique no botão de envio foi registrado anteriormente, porém não houve indicação visível de sucesso (mensagem 'obrigado') e o formulário permaneceu na página. Possíveis causas objetivas a investigar: validação do campo WhatsApp não satisfeita (número faltando DDD/format), falha de submissão no frontend, ou resposta do servidor que não altera a interface do formulário.\n\nRecomendações operacionais (opcionais):\n- Tentar reenviar usando um telefone com DDD válido (ex.: 11999999999) para verificar validação.\n- Checar console/network do navegador para erros na requisição de submissão.\n- Conferir se há um elemento alternativo de confirmação (modal, toast) que não contenha a palavra 'obrigado' mas indique sucesso.\n\nConclusão: A verificação solicitada — confirmar que a mensagem 'obrigado' é exibida e que o formulário é removido após o envio — falhou. Fornecidos os detalhes de presença/visibilidade dos elementos do formulário conforme acima.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "Medium",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/e4283418-8081-70a7-95f1-f4fc6b97d680/1771260923044143//tmp/test_task/result.webm",
    "created": "2026-02-16T16:52:33.634Z",
    "modified": "2026-02-16T16:55:23.483Z"
  },
  {
    "projectId": "a5b41820-de34-476a-9fd1-1dfd5aa01ae0",
    "testId": "83d53917-4004-4787-8a3e-4f11f0f8cd58",
    "userId": "e4283418-8081-70a7-95f1-f4fc6b97d680",
    "title": "TC012-Required-field error clears after entering a missing value and resubmitting",
    "description": "Verifies that a required-field validation error can be resolved by entering the missing data and submitting successfully.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'Vamos conversar?' link (likely anchor to #contato) to navigate to the contact section.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/section[1]/div[2]/div/div[3]/span[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'INICIAR RITUAL' / contact anchor (interactive element index 101) to navigate to the contact section (#contato) instead of scrolling again.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/header/div/nav/a[5]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the Submit button in the contact form to trigger the required-field validation message ('obrigatório').\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/section[9]/div/div[2]/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the missing fields: input 'Nome Corrigido' into Nome (index 6), input 'contato corrigido' into Contato/WhatsApp (index 7), then click the Submit button (index 1069) to attempt final submission.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/section[9]/div/div[2]/div/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Nome Corrigido')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/section[9]/div/div[2]/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('contato corrigido')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/section[9]/div/div[2]/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill both form fields with valid values (ensure WhatsApp uses a valid numeric phone), submit the form, then check the page for the success text 'obrigado'.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/section[9]/div/div[2]/div/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Nome Corrigido')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/section[9]/div/div[2]/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('11999999999')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/section[9]/div/div[2]/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=obrigado').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: After filling the required 'Nome' and 'Contato' fields and submitting the contact form, the expected success confirmation 'obrigado' did not appear — the form submission or success messaging did not complete as expected.\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Result: The required-field validation could not be confirmed as resolved because the form never reached the success message. Summary of observations and actions:\n\n- Navigation: The contact section (#contato) was reached via the 'INICIAR RITUAL' link (navigation successful).\n- Form fields: The 'Nome' and 'WhatsApp' fields were filled with valid-looking values (Nome: 'Nome Corrigido'; WhatsApp: '11999999999'). Input element indexes visible on page: name input index=3656, whatsapp input index=3659, submit button index=3661.\n- Submission attempts: The submit button was clicked multiple times (3 attempts). Each attempt was blocked by the browser's required-field validation; a native validation tooltip appeared in English reading: \"Please fill out this field.\" No Portuguese 'obrigatório' tooltip was observed.\n- Content search: Page search/scroll for 'obrigado' (success message) and 'obrigatório' (validation message) returned no matches.\n- Final status: success=false. The requested verification (that entering the missing data resolves the required-field validation and results in the 'obrigado' success message) could not be completed because the page continued to block submission with the browser's required-field validation and no success text was found.\n\nTechnical notes / possible causes (objective):\n- Native HTML5 required-field validation is firing and preventing form submission; the tooltip language showed English.\n- The page did not navigate to or render any success confirmation text after multiple valid-value submission attempts.\n\nIf further action is required, recommended next steps (not executed):\n- Inspect the form submission endpoint/server response (network) to check whether the form was submitted and what response was returned.\n- Try different phone formats (e.g., include country code +55) or remove/modify the 'required' attribute via JS to test server-side behavior.\n- Test in a real browser to capture the validation tooltip and network traffic.\n\nAll attempted steps and evidence are included above. The verification could not be completed with the current interactions.\n",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/e4283418-8081-70a7-95f1-f4fc6b97d680/1771261043468806//tmp/test_task/result.webm",
    "created": "2026-02-16T16:52:33.640Z",
    "modified": "2026-02-16T16:57:23.572Z"
  },
  {
    "projectId": "a5b41820-de34-476a-9fd1-1dfd5aa01ae0",
    "testId": "7c6e2447-9ee5-455a-b5f0-53b867628fd8",
    "userId": "e4283418-8081-70a7-95f1-f4fc6b97d680",
    "title": "TC013-Desktop fixed navigation is visible with backdrop-blur styling cues",
    "description": "Verifies the desktop header navigation is present and appears as a fixed, premium blurred menu container on the landing page.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/e4283418-8081-70a7-95f1-f4fc6b97d680/1771260803101165//tmp/test_task/result.webm",
    "created": "2026-02-16T16:52:33.646Z",
    "modified": "2026-02-16T16:53:23.215Z"
  },
  {
    "projectId": "a5b41820-de34-476a-9fd1-1dfd5aa01ae0",
    "testId": "bdc1226c-ee49-4c76-b3b8-f63a3f8fbd30",
    "userId": "e4283418-8081-70a7-95f1-f4fc6b97d680",
    "title": "TC014-Desktop menu anchor smoothly scrolls to Serviços section",
    "description": "Verifies clicking a desktop navigation anchor scrolls to the Serviços section and the target section is visibly in focus.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the desktop menu link labeled 'Serviços' (interactive element index 90). After click, verify URL updates and the Serviços section is visible.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/header/div/nav/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/e4283418-8081-70a7-95f1-f4fc6b97d680/1771260821398627//tmp/test_task/result.webm",
    "created": "2026-02-16T16:52:33.651Z",
    "modified": "2026-02-16T16:53:41.572Z"
  },
  {
    "projectId": "a5b41820-de34-476a-9fd1-1dfd5aa01ae0",
    "testId": "a821fbeb-a9ab-4417-9a58-21a78347663e",
    "userId": "e4283418-8081-70a7-95f1-f4fc6b97d680",
    "title": "TC015-Desktop menu anchor smoothly scrolls to Contato section",
    "description": "Verifies clicking a desktop navigation anchor scrolls to the Contato section and the target section becomes visible.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the desktop contact anchor alternative 'Vamos conversar?' (interactive element index 208) to trigger scroll to the Contato section.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/section[1]/div[2]/div/div[3]/span[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Contato').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Clicking the desktop 'Contato' anchor was expected to scroll to and reveal the Contato section (and update the URL with '#contato'), but the 'Contato' text/section did not become visible within the timeout\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Summary of findings and final status:\n\n- Goal: Verify that clicking a desktop navigation anchor labeled 'Contato' scrolls to the Contato section and makes that section visible.\n\n- Navigation: root page (http://localhost:3000) loaded successfully.\n\n- Attempts and results:\n  - Searched page and inspected interactive elements: no desktop navigation link labeled 'Contato' found in the visible navigation or footer links.\n  - Alternative contact anchor 'Vamos conversar?' (interactive element index 208) was clicked once; this action initiated a WhatsApp action and did not update the URL to include '#contato' nor scroll to a page section.\n  - A direct search/scroll to the text 'Contato' returned no matches; no element or section with visible text 'Contato' was found on the page.\n  - Scrolling to the bottom of the page revealed the footer and a contact form area ('Inicie seu Projeto'), but this section is not labeled 'Contato' and there is no '#contato' anchor present.\n\n- Assertions from the requested steps:\n  1) Click on desktop menu link labeled 'Contato' — Not possible: link not present on page. (FAILED)\n  2) Verify URL contains '#contato' — Did not occur after available clicks. (FAILED)\n  3) Verify element 'Contato section' is visible — No section with that label found. (FAILED)\n  4) Verify text 'Contato' is visible — Not found on page. (FAILED)\n\n- Additional observations:\n  - The site uses a dark premium aesthetic (visual inspection of the page and footer confirms dark styling).\n  - A floating/contact action 'Vamos conversar?' is present and triggers WhatsApp rather than an in-page anchor scroll.\n\n- Conclusion: Verification cannot be completed because the required desktop anchor 'Contato' is absent. The 'Vamos conversar?' element does not act as an in-page anchor to '#contato' but instead opens WhatsApp.\n\n- Recommended next steps for completing this verification:\n  1) Add or expose a desktop navigation link with text 'Contato' that points to an in-page anchor (e.g., href=\"#contato\"), or\n  2) Add an element on the page with id=\"contato\" and visible heading/text 'Contato' so an in-page link can target it, or\n  3) If the intended behavior is for 'Vamos conversar?' to scroll to the contact section, change its behavior so it scrolls to the in-page anchor instead of opening WhatsApp.\n\nIf specific instructions are provided to proceed differently (for example, verify a different anchor name or to test the WhatsApp action instead), proceed with the new instructions.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/e4283418-8081-70a7-95f1-f4fc6b97d680/1771260885554949//tmp/test_task/result.webm",
    "created": "2026-02-16T16:52:33.658Z",
    "modified": "2026-02-16T16:54:45.746Z"
  },
  {
    "projectId": "a5b41820-de34-476a-9fd1-1dfd5aa01ae0",
    "testId": "b8fe11d4-bb74-4439-b1b4-b3b5ea72b4d7",
    "userId": "e4283418-8081-70a7-95f1-f4fc6b97d680",
    "title": "TC016-Desktop navigation remains available after scrolling to a section",
    "description": "Verifies the navigation header remains visible after navigating to an in-page anchor, consistent with a fixed menu.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the desktop menu link labeled 'Serviços' to navigate to the in-page anchor and trigger the fixed header behavior.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/header/div/nav/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "Medium",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/e4283418-8081-70a7-95f1-f4fc6b97d680/1771260833225505//tmp/test_task/result.webm",
    "created": "2026-02-16T16:52:33.664Z",
    "modified": "2026-02-16T16:53:53.350Z"
  },
  {
    "projectId": "a5b41820-de34-476a-9fd1-1dfd5aa01ae0",
    "testId": "8b31cf48-eb2d-41f3-8824-abdb18a5c7cf",
    "userId": "e4283418-8081-70a7-95f1-f4fc6b97d680",
    "title": "TC017-Mobile overlay menu opens from the mobile menu icon",
    "description": "Verifies the mobile menu icon opens the overlay navigation and the overlay contents are visible.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Attempt to open the mobile overlay menu by clicking the available menu-related element (menu-close button index 125) to see if overlay toggles (if hamburger not present). If this doesn't open the overlay, use alternative approach next.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[5]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Sua jornada estelar').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The test attempted to open the mobile menu and verify that the overlay navigation and its links are visible; expected to see 'Sua jornada estelar' in the overlay but it did not appear, indicating the mobile overlay did not open or the overlay contents are missing.\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Result: Verification could not be completed. Reason: Mobile menu (hamburger) icon is not visible in the current desktop layout. Observations: the DOM contains a 'menu-close' button (index 125) which suggests an overlay exists, but no menu-open hamburger is exposed at this viewport. Actions already executed: navigated to '/', scrolled to 'menu', clicked menu-close (index 125) once. Outcome: mobile-menu-open behavior cannot be verified from desktop layout. Recommended next steps: 1) Re-run the check with a mobile viewport (narrow window or device emulation) so the hamburger appears, then click the hamburger and assert overlay and links; or 2) provide instructions to simulate mobile user-agent or URL fragment that forces mobile menu. All other extra visual checks remain pending. Success: false",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/e4283418-8081-70a7-95f1-f4fc6b97d680/177126084240027//tmp/test_task/result.webm",
    "created": "2026-02-16T16:52:33.669Z",
    "modified": "2026-02-16T16:54:02.568Z"
  },
  {
    "projectId": "a5b41820-de34-476a-9fd1-1dfd5aa01ae0",
    "testId": "82228a8e-1c4d-4cc6-b4c3-52821df35b85",
    "userId": "e4283418-8081-70a7-95f1-f4fc6b97d680",
    "title": "TC018-Mobile overlay menu link closes overlay and scrolls to Serviços",
    "description": "Verifies selecting a link in the mobile overlay closes the overlay and navigates to the Serviços section.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'Services' link (to simulate selecting Serviços from the mobile overlay) and then check the page to verify the Serviços section is visible and the mobile overlay has closed (inferred by absence of menu-close button).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/header/div/nav/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Serviços').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: clicking the 'Serviços' link in the mobile overlay should have closed the overlay and navigated to the 'Serviços' section, but the 'Serviços' section was not visible — navigation or overlay close failed\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Result summary:\n- Navigation: Page navigated to http://localhost:3000/#servicos (Services section). The Serviços content is visible (e.g., section heading and service cards such as 'Arquitetura de Autoridade', 'Retenção Cinematográfica', 'Alquimia Visual & IA', 'Sistemas Nervosos').\n- Overlay close check: Interactive element index 126 (button id=menu-close) is present in the interactive elements list. This indicates the mobile overlay/menu is still present and was not closed by selecting the link.\n- Conclusion: The action of selecting the Serviços link navigated to the Serviços section (SUCCESS) but did not close the mobile overlay (FAIL). Overall verification failed because the overlay did not close as required.\n- Evidence: Current tab URL: http://localhost:3000/#servicos; interactive elements list contains [126]<button id=menu-close aria-label=Fechar menu />; visible page content shows the Serviços area (screenshot of Grid de Autoridade and service cards).\n- Recommended next steps: (1) If testing mobile overlay flow, open mobile menu (click hamburger) and then click the Serviços link inside that overlay and re-check whether index 126 disappears. (2) If the link being clicked was from the desktop nav instead of the overlay, ensure the mobile overlay link is targeted and tested on a mobile/responsive viewport.\nTask complete: Overall success=false because the overlay did not close after selecting the link. ",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/e4283418-8081-70a7-95f1-f4fc6b97d680/1771260848203347//tmp/test_task/result.webm",
    "created": "2026-02-16T16:52:33.675Z",
    "modified": "2026-02-16T16:54:08.315Z"
  },
  {
    "projectId": "a5b41820-de34-476a-9fd1-1dfd5aa01ae0",
    "testId": "168e615c-672c-4a25-90d5-f84a77987dd1",
    "userId": "e4283418-8081-70a7-95f1-f4fc6b97d680",
    "title": "TC019-Mobile overlay menu link closes overlay and scrolls to Contato",
    "description": "Verifies selecting a link in the mobile overlay closes the overlay and navigates to the Contato section.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the overlay menu link labeled 'Contato' (using the 'Vamos conversar?' anchor at index 88 as the contact link) to navigate to the contact section and observe whether the overlay closes.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/section[1]/div[2]/div/div[3]/span[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the overlay menu link labeled 'Vamos conversar?' (use element index 88) to trigger navigation to the Contato section and observe whether the overlay closes.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/section[1]/div[2]/div/div[3]/span[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the overlay menu link labeled 'Vamos conversar?' (element 88) to navigate to the Contato section and observe whether the overlay closes.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/section[1]/div[2]/div/div[3]/span[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the overlay contact link labeled 'Vamos conversar?' (element index 88) to navigate to the Contato section and observe whether the overlay closes.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/section[1]/div[2]/div/div[3]/span[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the overlay contact link 'Vamos conversar?' (element index 88) to trigger navigation to the Contato section and observe whether the overlay closes.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/section[1]/div[2]/div/div[3]/span[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the overlay menu link 'Vamos conversar?' (element index 88) to attempt navigation to the Contato section and observe whether the overlay closes.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/section[1]/div[2]/div/div[3]/span[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the overlay contact link 'Vamos conversar?' (element index 88) to attempt navigation to the Contato section and observe whether the overlay closes.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/section[1]/div[2]/div/div[3]/span[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the overlay menu link 'Vamos conversar?' (element index 88) to attempt navigation to the Contato section and observe whether the overlay closes.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/section[1]/div[2]/div/div[3]/span[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the overlay menu link 'Vamos conversar?' (element index 88) to attempt navigation to the Contato section and observe whether the overlay closes.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/section[1]/div[2]/div/div[3]/span[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the overlay menu link 'Vamos conversar?' (element index 88) to navigate to the Contato section and observe whether the overlay closes.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/section[1]/div[2]/div/div[3]/span[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the overlay menu link 'Vamos conversar?' (element index 88) to attempt navigation to the Contato section and observe whether the overlay closes.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/section[1]/div[2]/div/div[3]/span[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the overlay menu link 'Vamos conversar?' (element index 88) to navigate to the Contato section, wait for the page to update, scroll to the bottom, and search for the 'Contato' text to verify navigation. Then confirm overlay closed (absence of menu-close).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/section[1]/div[2]/div/div[3]/span[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click an overlay/menu link that should navigate to the contact/Contato section and observe whether the overlay closes. Use a different link index (not 88) since 88 is no longer available; try the 'INICIAR RITUAL' link at index 52.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/header/div/nav/a[5]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Contato').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Expected that clicking the mobile overlay link would close the overlay and navigate to the 'Contato' section, but the 'Contato' section did not become visible — the overlay may have stayed open or navigation did not occur.\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Test result summary:\n- Objective: Verify selecting a link in the mobile overlay closes the overlay and navigates to the Contato section.\n- Actions executed: clicked overlay contact-like links (element 88 attempted earlier, element 52 'INICIAR RITUAL' clicked).\n- Navigation: Success — page navigated to the Contato anchor (current tab shows #contato and contact form 'Inicie seu Projeto' is visible).\n- Overlay close behavior: Failure — mobile overlay remained open after link selection (menu-close button present as interactive element index 59).\n- Conclusion: The link selection navigates to the Contato section but does NOT close the mobile overlay. This means the expected behavior (overlay closes on link selection) is not met.\n- Recommendation: Fix overlay behavior so link selection triggers overlay close (ensure link click handler closes overlay or perform navigation via normal anchor behavior).\n- Status: Stopping as requested. Test outcome: success=false.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/e4283418-8081-70a7-95f1-f4fc6b97d680/1771261208099673//tmp/test_task/result.webm",
    "created": "2026-02-16T16:52:33.681Z",
    "modified": "2026-02-16T17:00:08.220Z"
  },
  {
    "projectId": "a5b41820-de34-476a-9fd1-1dfd5aa01ae0",
    "testId": "b9874c56-8bbe-4a7c-be37-05445002ce7d",
    "userId": "e4283418-8081-70a7-95f1-f4fc6b97d680",
    "title": "TC020-Negative: Mobile menu overlay fails to open when tapping menu icon (unresponsive state)",
    "description": "Validates the failure mode where the mobile overlay menu does not open and remains inaccessible after interaction.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=mobile menu icon (hamburger)').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The test was verifying that after clicking the hamburger the mobile overlay menu remains closed and the mobile menu icon (hamburger) stays visible, but the expected hamburger icon element did not appear/was not visible — the failure-mode (overlay remaining inaccessible) could not be confirmed\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Validation summary and findings (stopping):\n\n- Steps requested: 1) Navigate to / (done). 2) Verify mobile menu icon (hamburger) visibility (attempted). 3) Click the hamburger. 4) Verify mobile overlay menu is not visible. 5) Verify hamburger remains visible.\n\n- What was performed: Navigation to http://localhost:3000 completed. An attempt was made to locate the mobile menu icon by scrolling to 'menu' (result: 'Scrolled to text: menu'). The page DOM was inspected for interactive elements.\n\n- Findings relevant to the mobile menu failure mode:\n  - No explicit 'open menu' / hamburger element index was found in the current interactive element list. The only menu-related button present in the interactive list is a button with id=menu-close (aria-label='Fechar menu') [index 125], which is a close control (likely for an already-open overlay) rather than the hamburger/open control.\n  - The page appears in a desktop header layout (nav links Services [89], Portfolio [92], Process [95], FAQ [98], CTA INICIAR RITUAL [101]) and does not expose a mobile hamburger control in this viewport.\n  - A WhatsApp chat element is present ([index 203], text 'Resposta rápida no WhatsApp.'), indicating the floating WhatsApp button exists.\n  - No mobile overlay menu element was observed in the current interactive elements list; therefore it is not possible to click a hamburger to test whether the overlay fails to open from this viewport.\n\n- Conclusion regarding the requested failure-mode validation:\n  - The test cannot be completed as specified because the mobile hamburger (open-menu) control is not available in the current page state (desktop layout). Without an open-menu control index or a way to switch to a mobile viewport from the current page, the sequence \"click hamburger -> verify overlay not visible -> verify hamburger visible\" cannot be executed.\n\n- Recommendation to proceed (suggested next steps outside current run):\n  1) Emulate a mobile viewport or provide the page in mobile layout (so the hamburger/open-menu control is present). 2) Re-run the test and click the hamburger open control. 3) If the hamburger click does not open the overlay, capture the DOM state (menu-close present but overlay absent) and include console/network logs to help debug event handlers.\n\n- Result: Task stopped. Required validation steps not completed due to missing mobile/open-menu control in current viewport.\n\nIf a mobile hamburger control should exist in the page, provide instructions to emulate mobile viewport or supply the element index for the hamburger; the test can be retried.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "Low",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/e4283418-8081-70a7-95f1-f4fc6b97d680/1771260828416593//tmp/test_task/result.webm",
    "created": "2026-02-16T16:52:33.688Z",
    "modified": "2026-02-16T16:53:48.566Z"
  },
  {
    "projectId": "a5b41820-de34-476a-9fd1-1dfd5aa01ae0",
    "testId": "d57f3312-3a62-4d14-a79e-59f44677046a",
    "userId": "e4283418-8081-70a7-95f1-f4fc6b97d680",
    "title": "TC021-Scroll reveal adds reveal classes when elements enter viewport",
    "description": "Verifies content elements visually transition into view as the page is scrolled down, indicating reveal behavior is triggered.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Sua jornada estelar').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Expected the 'Sua jornada estelar' section to reveal and become visible when scrolling (verifying reveal-on-scroll behavior), but the section did not appear or remained hidden/collapsed.\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Summary of verification and findings:\n\n- What was performed:\n  - Navigated to http://localhost:3000 and verified the hero heading/subheading are present.\n  - Scrolled down; the section 'Grid de Autoridade' and its card images are visible in the screenshot and DOM (content below the hero is rendered).\n  - Located the 'Sua jornada estelar' section in the page content and enumerated its six steps.\n  - Located the floating WhatsApp UI text and CTA anchor. The WhatsApp CTA anchor exists in the DOM (interactive element index [208] in the browser state) but its href is a placeholder '#'.\n  - Extracted and listed page anchors/links (see list below).\n\n- Reveal-on-scroll verification result:\n  - Cannot confirm: There is insufficient evidence to assert that content visually transitions (animates/changes opacity/slide-in) as it scrolls into view. The provided markdown and DOM snapshot contain content but not runtime CSS or JS state changes (no captured animation classes or computed-style changes). The screenshot shows the content after scrolling, but that alone does not prove a reveal animation occurred during the scroll.\n\n- Links / anchors found (unique list & flags):\n  - #servicos — internal fragment link (present)\n  - #portfolio — internal fragment link (present)\n  - #processo — internal fragment link (present)\n  - #faq — internal fragment link (present)\n  - #contato — internal fragment link (present)\n  - # — multiple occurrences (placeholder/hash links). Examples: 'Vamos conversar?' (WhatsApp CTA) points to '#'. Flag: placeholder — not a real external/WhatsApp deeplink.\n  - No fully-qualified external URLs or WhatsApp deeplink found in the provided DOM/markdown.\n\n- Visual / styling checks:\n  - 'Sua jornada estelar' content is present in the page text. Styling and Dark Premium aesthetic consistency cannot be validated from the markdown alone; visual confirmation would require inspecting computed styles or higher-resolution screenshots of that section.\n\n- Recommendations to conclusively confirm reveal-on-scroll behavior:\n  1) Record a short screen capture while scrolling from the hero into the next section and review for visible transitions (fade/slide) on the content blocks.\n  2) Open browser devtools > Elements and observe class changes while scrolling (watch for classes like 'is-visible', 'reveal', or similar being added), or watch the computed styles (opacity/transform) to detect transitions.\n  3) Inspect JavaScript for IntersectionObserver usage or scroll event handlers controlling reveal animations.\n\nConclusion: The page content below the hero is present and visible after scrolling, but reveal-on-scroll transitions could not be confirmed with the available artifacts. To fully complete the requested verification, one of the recommended inspection methods above is required.\n\nFiles to display: none.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/e4283418-8081-70a7-95f1-f4fc6b97d680/177126086929742//tmp/test_task/result.webm",
    "created": "2026-02-16T16:52:33.693Z",
    "modified": "2026-02-16T16:54:29.457Z"
  },
  {
    "projectId": "a5b41820-de34-476a-9fd1-1dfd5aa01ae0",
    "testId": "1a31d7e2-e40b-41f1-be4e-7b1a0a00deb8",
    "userId": "e4283418-8081-70a7-95f1-f4fc6b97d680",
    "title": "TC022-Multiple reveal elements trigger as user continues scrolling",
    "description": "Verifies additional elements reveal progressively as they enter the viewport during continued scrolling.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "Medium",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/e4283418-8081-70a7-95f1-f4fc6b97d680/1771260979936369//tmp/test_task/result.webm",
    "created": "2026-02-16T16:52:33.699Z",
    "modified": "2026-02-16T16:56:20.143Z"
  },
  {
    "projectId": "a5b41820-de34-476a-9fd1-1dfd5aa01ae0",
    "testId": "449757ca-a33d-45f1-8422-fc636dfde333",
    "userId": "e4283418-8081-70a7-95f1-f4fc6b97d680",
    "title": "TC023-Landing page provides SEO metadata for title and description",
    "description": "Verifies the landing page exposes basic SEO metadata in visible page content and title.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/e4283418-8081-70a7-95f1-f4fc6b97d680/1771260880053485//tmp/test_task/result.webm",
    "created": "2026-02-16T16:52:33.706Z",
    "modified": "2026-02-16T16:54:40.178Z"
  },
  {
    "projectId": "a5b41820-de34-476a-9fd1-1dfd5aa01ae0",
    "testId": "2498d0c5-16f2-4918-bd74-439cff597a2c",
    "userId": "e4283418-8081-70a7-95f1-f4fc6b97d680",
    "title": "TC024-Open Graph / social preview content is reflected by visible hero messaging",
    "description": "Validates that the visible hero copy aligns with what would be expected for social preview title/description configuration.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "Medium",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/e4283418-8081-70a7-95f1-f4fc6b97d680/1771260802237567//tmp/test_task/result.webm",
    "created": "2026-02-16T16:52:33.712Z",
    "modified": "2026-02-16T16:53:22.410Z"
  },
  {
    "projectId": "a5b41820-de34-476a-9fd1-1dfd5aa01ae0",
    "testId": "3ac501e3-5bc7-4fbd-95cd-6c95e7c346c8",
    "userId": "e4283418-8081-70a7-95f1-f4fc6b97d680",
    "title": "TC025-Keyboard navigation: Tab reaches primary interactive elements in the header/hero",
    "description": "Ensures key call-to-action and navigation elements are reachable by keyboard and show a clear focus target.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/e4283418-8081-70a7-95f1-f4fc6b97d680/1771260836844296//tmp/test_task/result.webm",
    "created": "2026-02-16T16:52:33.718Z",
    "modified": "2026-02-16T16:53:57.078Z"
  },
  {
    "projectId": "a5b41820-de34-476a-9fd1-1dfd5aa01ae0",
    "testId": "ca020fb3-3d18-4a08-8f9e-385ad7bc3fcb",
    "userId": "e4283418-8081-70a7-95f1-f4fc6b97d680",
    "title": "TC026-Keyboard navigation: Enter activates a focused call-to-action without requiring a mouse",
    "description": "Verifies a focused interactive control can be activated using the keyboard to progress the user journey.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Sua jornada estelar').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The test attempted to activate a focused interactive control using keyboard (Tab, Tab, Enter) to progress the user journey and reveal the 'Sua jornada estelar' section, but the expected section did not appear or was not visible\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Summary of results:\n- Keyboard activation: Success. Focus moved to the 'Portfolio' nav item via Tab (twice) and Enter activated it; the page navigated to the portfolio anchor (#portfolio).\n- URL check: Exact current URL: http://localhost:3000/#portfolio. Contains '/'? yes.\n- <main> element visibility: not visible. (No visible <main> element text available; first 100 characters: N/A)\n- Visual/aesthetic checks (limited, observational): Dark Premium aesthetic is present in the visible hero (dark background, large white headline, purple/blue accent). No unexpected UI errors observed in the hero area.\n- 'Sua jornada estelar' section: Not found / not observed on the current page view (no matching element text in page state).\n- Floating WhatsApp button: Present in DOM (page elements include text \"Resposta rápida no WhatsApp.\" and a link labelled similar to \"Vamos conversar?\"). Functionality not programmatically clicked — presence confirmed in DOM.\n- Links: 8 links present on the page (per page state). Full accessibility checks (keyboard focus order beyond the tested nav item, ARIA attributes, contrast checks, or link target verification) were not performed.\nConclusion and status: The primary goal — verifying that a focused interactive control can be activated via keyboard to progress the user journey — succeeded. However, one of the required assertions (visibility of the <main> element) failed: <main> is not visible. Because not all requested assertions passed, overall task success is set to false.\nRecommended next steps (optional): If the <main> element must be visible for the user journey, inspect why the <main> is hidden (CSS/display, ARIA, or rendering issue) or scroll / reveal additional content and recheck. For a deeper accessibility validation, run a focused audit (tab order across entire page, ARIA roles, contrast ratios, and link targets).\n",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/e4283418-8081-70a7-95f1-f4fc6b97d680/1771260871685312//tmp/test_task/result.webm",
    "created": "2026-02-16T16:52:33.724Z",
    "modified": "2026-02-16T16:54:31.805Z"
  },
  {
    "projectId": "a5b41820-de34-476a-9fd1-1dfd5aa01ae0",
    "testId": "91029a5b-0d07-4d5b-90a7-0edb13ae3d87",
    "userId": "e4283418-8081-70a7-95f1-f4fc6b97d680",
    "title": "TC027-Screen-reader-friendly structure: semantic landmarks are present",
    "description": "Checks that the page uses semantic landmarks to support screen reader navigation (visibly present structural elements).",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/e4283418-8081-70a7-95f1-f4fc6b97d680/1771260856659454//tmp/test_task/result.webm",
    "created": "2026-02-16T16:52:33.730Z",
    "modified": "2026-02-16T16:54:16.842Z"
  },
  {
    "projectId": "a5b41820-de34-476a-9fd1-1dfd5aa01ae0",
    "testId": "2fabe56d-5552-4ea6-9963-a8fa8ed1ac92",
    "userId": "e4283418-8081-70a7-95f1-f4fc6b97d680",
    "title": "TC028-Material Symbols/icons do not replace critical text labels for CTAs",
    "description": "Ensures iconography does not remove essential visible labels needed for accessibility and comprehension.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "Medium",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/e4283418-8081-70a7-95f1-f4fc6b97d680/1771260944654771//tmp/test_task/result.webm",
    "created": "2026-02-16T16:52:33.736Z",
    "modified": "2026-02-16T16:55:44.764Z"
  },
  {
    "projectId": "a5b41820-de34-476a-9fd1-1dfd5aa01ae0",
    "testId": "f61c5bbd-239c-4568-ae0c-f84c11d97bf2",
    "userId": "e4283418-8081-70a7-95f1-f4fc6b97d680",
    "title": "TC029-Edge case: validate remediation requirement when metadata is missing (manual negative check)",
    "description": "Documents the expected failure mode when social metadata is absent; verifies visible indicators that metadata configuration is incomplete cannot be confirmed from the UI alone.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "Low",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/e4283418-8081-70a7-95f1-f4fc6b97d680/1771260824208988//tmp/test_task/result.webm",
    "created": "2026-02-16T16:52:33.742Z",
    "modified": "2026-02-16T16:53:44.314Z"
  }
]
